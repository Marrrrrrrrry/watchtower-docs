import{_ as t,c as n,o as a,ae as o}from"./chunks/framework.CBQY1fUt.js";const p=JSON.parse('{"title":"Linked containers","description":"","frontmatter":{},"headers":[],"relativePath":"linked-containers.md","filePath":"linked-containers.md","lastUpdated":1763853533000}'),i={name:"linked-containers.md"};function r(s,e,d,c,l,h){return a(),n("div",null,[...e[0]||(e[0]=[o('<h1 id="linked-containers" tabindex="-1">Linked containers <a class="header-anchor" href="#linked-containers" aria-label="Permalink to &quot;Linked containers&quot;">â€‹</a></h1><p>Watchtower will detect if there are links between any of the running containers and ensures that things are stopped/started in a way that won&#39;t break any of the links. If an update is detected for one of the dependencies in a group of linked containers, watchtower will stop and start all of the containers in the correct order so that the application comes back up correctly.</p><p>For example, imagine you were running a <em>mysql</em> container and a <em>wordpress</em> container which had been linked to the <em>mysql</em> container. If watchtower were to detect that the <em>mysql</em> container required an update, it would first shut down the linked <em>wordpress</em> container followed by the <em>mysql</em> container. When restarting the containers it would handle <em>mysql</em> first and then <em>wordpress</em> to ensure that the link continued to work.</p><p>If you want to override existing links, or if you are not using links, you can use special <code>com.centurylinklabs.watchtower.depends-on</code> label with dependent container names, separated by a comma.</p><p>When you have a depending container that is using <code>network_mode: service:container</code> then watchtower will treat that container as an implicit link.</p>',5)])])}const u=t(i,[["render",r]]);export{p as __pageData,u as default};
