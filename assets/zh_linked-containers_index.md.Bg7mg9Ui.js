import{_ as t,c as a,o,ae as r}from"./chunks/framework.CBQY1fUt.js";const _=JSON.parse('{"title":"链接容器","description":"","frontmatter":{},"headers":[],"relativePath":"zh/linked-containers/index.md","filePath":"zh/linked-containers/index.md","lastUpdated":1763853533000}'),n={name:"zh/linked-containers/index.md"};function s(d,e,m,c,i,l){return o(),a("div",null,[...e[0]||(e[0]=[r('<h1 id="链接容器" tabindex="-1">链接容器 <a class="header-anchor" href="#链接容器" aria-label="Permalink to &quot;链接容器&quot;">​</a></h1><p>Watchtower 会检测正在运行的容器之间的链接，并确保以不会破坏链接的方式停止/启动容器。如果在一组已链接容器中某个依赖项需要更新，watchtower 会按正确顺序停止并启动所有容器，确保应用能够正确恢复。</p><p>例如，假设你运行了一个 <em>mysql</em> 容器以及一个链接到 <em>mysql</em> 的 <em>wordpress</em> 容器。如果 watchtower 检测到 <em>mysql</em> 容器需要更新，它会先停止链接的 <em>wordpress</em> 容器，然后再停止 <em>mysql</em> 容器。重启时会先启动 <em>mysql</em>，然后启动 <em>wordpress</em>，以确保链接持续有效。</p><p>如果你希望覆盖已有的链接，或未使用链接功能，可以使用特殊标签 <code>com.centurylinklabs.watchtower.depends-on</code> 指定依赖的容器名称（使用逗号分隔）。</p><p>当某个依赖容器使用 <code>network_mode: service:container</code> 时，watchtower 会将其视为隐式链接。</p>',5)])])}const h=t(n,[["render",s]]);export{_ as __pageData,h as default};
